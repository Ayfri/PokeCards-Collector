---
import "~/styles/colors.css";

import type {GetStaticPaths} from 'astro';
import {getCards, getPokemons} from '$helpers/data';
import Layout from '@layouts/Layout.astro';
import PokemonDisplay from '@components/card/PokemonDisplay.svelte';
import type {FullCard, Pokemon} from "~/types.d.ts";
import { spriteCache } from '~/stores/spriteCache';

export const getStaticPaths = (async () => {
	const pokemons = await getPokemons();
	let allCards = await getCards();
	allCards = allCards.sort((a, b) => a.pokemon.id - b.pokemon.id || (b.price ?? 0) - (a.price ?? 0));
	allCards = allCards.filter((card, index, self) => self.findIndex(c => c.image === card.image) === index);

	return pokemons.map(pokemon => {
		const pokemonCards = allCards.filter(c => parseInt(c.numero) === pokemon.id && c.set);
		if (!pokemonCards.length) return undefined;

		return {
			params: {
				numero: pokemon.id,
			},
			props: {
				cards: pokemonCards,
			},
		};
	}).filter(x => !!x);
}) satisfies GetStaticPaths;

interface Props {
	cards: FullCard[];
}

const {cards} = Astro.props;
const pokemons = await getPokemons();
const card = cards[0];
const pokemonName = card.pokemon.name;
const capitalizedPokemonName = pokemonName.charAt(0).toUpperCase() + pokemonName.slice(1);

// Préchargement des sprites pour la chaîne d'évolution
const currentPokemon = card.pokemon;

// Find pre-evolution if it exists
const preEvolution = currentPokemon.evolves_from ?
	pokemons.find(pokemon => pokemon.id === currentPokemon.evolves_from) :
	undefined;

// Find pre-pre-evolution if it exists (for 3-stage chains)
const prePreEvolution = preEvolution?.evolves_from ?
	pokemons.find(pokemon => pokemon.id === preEvolution.evolves_from) :
	undefined;

// Find evolutions if they exist
const evolutions = currentPokemon.evolves_to ?
	currentPokemon.evolves_to.map(evoId => pokemons.find(pokemon => pokemon.id === evoId)) :
	[];

// Find further evolutions if they exist
const furtherEvolutions = evolutions.length ?
	evolutions.flatMap(evo =>
		evo?.evolves_to ?
			evo.evolves_to.map(furtherEvoId => pokemons.find(pokemon => pokemon.id === furtherEvoId)) :
			[]
	) :
	[];

// Build the full chain
const fullChain: Pokemon[] = [];

if (prePreEvolution) fullChain.push(prePreEvolution);
if (preEvolution) fullChain.push(preEvolution);
fullChain.push(currentPokemon);
evolutions.forEach(evo => {
	if (evo) fullChain.push(evo);
});
furtherEvolutions.forEach(evo => {
	if (evo) fullChain.push(evo);
});

// Remove duplicates if any
const uniqueChain = fullChain.filter((pokemon, index, self) =>
	index === self.findIndex(p => p.id === pokemon.id)
);

// Préchargement des sprites
const sprites = await Promise.all(
	uniqueChain.map(async (pokemon) => ({
		id: pokemon.id,
		sprite: await spriteCache.getSprite(pokemon.id)
	}))
);

const spritesMap = Object.fromEntries(
	sprites.map(({id, sprite}) => [id, sprite])
);
---

<Layout
	title={`${capitalizedPokemonName} - Cards`}
	description={`${capitalizedPokemonName}: ${card.pokemon.description}`}
	image={{
		url: card.image,
		alt: card.pokemon.description,
	}}
>
	<main class="max-w-[100vw] m-auto p-2 text-lg text-white">
		<div class="mt-10 mx-auto flex flex-col gap-8 w-[90%] -z-10 max-lg:mt-8">
			<PokemonDisplay client:load {cards} {pokemons} sprites={spritesMap}/>
		</div>
	</main>
</Layout>
